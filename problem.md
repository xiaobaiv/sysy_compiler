## 问题与解决方案记录(开发日志)

### 2024/5/21

#### Q0: 多个文件中的子类如何共享一个父类的变量（类似全局变量的效果）？
**A0:** 通过将父类的变量设置为静态变量，然后通过父类的静态方法来访问这个变量。这样就可以实现多个子类共享一个父类的变量的效果。需要注意的是，需要在 `base_ast.cpp` 中定义（只1次）这个静态变量。还需在原有的makefile中将ast文件夹中的源文件加入到编译中，否则会出现未定义的错误。

### 2024/5/22

#### Q1: Koopa IR 的内存形式中，block包含多个value，value可以看做是一系列指令的集合，如何遍历这些指令更好？
**A1:** 
- **v0:** 遍历slice，同时在binary中重复visit op 的数据对象。这就会导致重复生成目标代码。
- **v1:** 分析block可知，其中的指令是线性分布的，也就是可以看做棵树，树根是最后一个指令。优点是无需引入额外的数据结构，缺点是会造成寄存器的挤压（树的dfs实际上用到了栈），此外，有个悬而未决的问题，就是是否对块的跳转是透明的（应该是的）。
- **v2:** 引入unordered_map, 记录指令结果，避免重复visit，生成重复目标代码。
- **补充（2024/5/23）:** 通过阅读文档优化部分Lv9+.3部分，发现v1方法可以实现无关代码的删除（aka dead code elimination），这样可以减少目标代码的长度，提高程序的运行效率。

#### Q2: 寄存器分配的问题，如何解决？
**A2:** 引入寄存器管理器RegManager封装，使得寄存器的分配更加方便，同时也可以避免寄存器的挤压。同时，也便于后续分配算法的实现（如果有时间的话）。

#### Q3: 找寻寄存器分配的规律？
**A3:** 通过观察，发现寄存器分配的规律是，如果一个寄存器存储的结果参与运算，则这个寄存器可以被释放。通常，释放后的寄存器会被下一个指令使用。这样就可以实现寄存器的复用。

#### Q4: 如何判定什么时候使用addi, 什么时候使用add？
**A4:** 为了简便，所有的立即数都需要先存储到寄存器中，然后再进行运算。当然，这样会造成寄存器的浪费。但是，这样可以简化指令的选择。如果有时间的话，可以考虑优化这一部分。

#### Q5: koopa IR 不支持逻辑与和逻辑或，如何解决？
**A5:** koopa IR 不支持逻辑或，需要按位或，然后与0比较，得到结果；koopa IR 不支持两个数直接与，需要判断两个数是否都不为0，然后按位与。
